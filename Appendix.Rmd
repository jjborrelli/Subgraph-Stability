---
title: 'Appendix - Selection against instability: stable subgraphs are most frequent
  in empirical food webs'
author: "Jonathan J. Borrelli"
date: "Wednesday, July 23, 2014"
output:
  pdf_document:
    toc: yes
  html_document:
    highlight: tango
    number_sections: yes
    toc: yes
---

```{r, echo = F, message = F}
require(knitr)
opts_chunk$set(message = F, comment = NA)
```

--------------------------------------------------
  
[The code provided here can also be obtained from GitHub by clicking this link](https://github.com/jjborrelli/Subgraph-Stability)

# Definitions  

## Subgraph Library  

The following code defines the sign matrix for each of the thirteen possible three-node subgraphs. Here, the "s" in the object name indicates that only single links are used, while a "d" indicates the presence of double links.   

```{r library}
s1<-matrix(c(0,1,0,-1,0,1,0,-1,0),nrow=3,ncol=3)
s2<-matrix(c(0,1,1,-1,0,1,-1,-1,0),nrow=3,ncol=3)
s3<-matrix(c(0,1,-1,-1,0,1,1,-1,0),nrow=3,ncol=3)
s4<-matrix(c(0,1,1,-1,0,0,-1,0,0),nrow=3,ncol=3)
s5<-matrix(c(0,0,1,0,0,1,-1,-1,0),nrow=3,ncol=3)

d1<-matrix(c(0,1,1,-1,0,1,-1,1,0),nrow=3,ncol=3)
d2<-matrix(c(0,1,1,1,0,1,-1,-1,0),nrow=3,ncol=3)
d3<-matrix(c(0,1,-1,1,0,0,1,0,0),nrow=3,ncol=3)
d4<-matrix(c(0,1,1,-1,0,0,1,0,0),nrow=3,ncol=3)
d5<-matrix(c(0,1,1,-1,0,1,1,-1,0),nrow=3,ncol=3)
d6<-matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,ncol=3)
d7<-matrix(c(0,1,1,1,0,1,1,-1,0),nrow=3,ncol=3)
d8<-matrix(c(0,1,1,1,0,0,1,0,0),nrow=3,ncol=3)

mot.lst <- list(s1, s2, s3, s4, s5, d1, d2, d3, d4, d5, d6, d7, d8)
names(mot.lst) <- c("s1", "s2", "s3", "s4", "s5", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8")

```

## Define required functions

### Functions for counting motifs

The `motif_counter` function takes in a list of graph objects and applies `triad.census` to each. It returns a data frame of the frequency of each connected three-node digraph. 

```{r counter}
motif_counter <- function(graph.lists){
  require(igraph)
  
  if(!is.list(graph.lists)){
    stop("The input should be a list of graph objects")
  }
  
  triad.count <- lapply(graph.lists, triad.census)
  triad.matrix <- matrix(unlist(triad.count), nrow = length(graph.lists), ncol = 16, byrow = T)
  colnames(triad.matrix) <- c("empty", "single", "mutual", "s5", "s4", "s1", "d4",
                              "d3", "s2", "s3","d8", "d2", "d1", "d5", "d7", "d6")
  
  triad.df <- as.data.frame(triad.matrix)
  
  motif.data.frame <- data.frame(s1 = triad.df$s1, s2 = triad.df$s2, s3 = triad.df$s3, s4 = triad.df$s4, 
                                 s5 = triad.df$s5, d1 = triad.df$d1, d2 = triad.df$d2, d3 = triad.df$d3, d4 = triad.df$d4,
                                 d5 = triad.df$d5, d6 = triad.df$d6, d7 = triad.df$d7, d8 = triad.df$d8)
  
  rownames(motif.data.frame) <- names(graph.lists)
  return(motif.data.frame)
}
```

The `permutes_rc` function is a null model that generates `iter` number of permuted matrices from the input matrix (`mat`). Each permuted matrix is created by randomly sampling 2x2 submatrices matching the pattern 
```{r echo = F, comment = NA} 
matrix(c(0,1,1,0), nrow = 2, ncol = 2)
``` 
or 
```{r echo = F, comment = NA}
matrix(c(1,0,0,1), nrow = 2, ncol = 2)
``` 
and swapping the 0s and 1s. This null model preserves the number of prey and predators of each species (the degree distribution). 

```{r null.model}
permutes_rc <- function(mat, iter = 100){
  
  pattern1 <- matrix(c(0,1,1,0), nrow = 2, ncol = 2)
  pattern2 <- matrix(c(1,0,0,1), nrow = 2, ncol = 2)
  count <- 0
  
  mat.list <- list()
  for(i in 1:iter){
    mat.list[[i]] <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))
  }
  
  while(count < iter){
    srow <- sample(1:nrow(mat), 2)
    scol <- sample(1:ncol(mat), 2)
    
    test <- mat[srow, scol]
    
    if(sum(test == pattern1) == 4){
      count <- count + 1
      mat[srow, scol] <- pattern2
      mat.list[[count]] <- mat
      
      next
    } else if(sum(test == pattern2) == 4){
      count <- count + 1
      mat[srow, scol] <- pattern1
      mat.list[[count]] <- mat
      
      next
    } else {next}
  }
  
  matrices <- lapply(mat.list, as.matrix)
  return(permuted.matrices = matrices)
}

```


### Functions for determining quasi sign-stability
There are two main functions for determining quasi sign-stability, and a third that wraps them together to generate the desired number of iterations. 

The function `ran.unif` takes an input of a signed matrix. It will then check each cell to see if there is a 1 or -1. Each 1 will be replaced by a value drawn from the random uniform distribution between 0 and 10, while each -1 is replaced by a value from the random uniform distribution between -1 and 0. The `ran.unif` function also assigns values to the diagonal from a random uniform distribition between -1 and 0. The resulting randomly sample matrix is returned.  

```{r}
ran.unif <- function(motmat){
  newmat <- apply(motmat, c(1,2), function(x){
    if(x==1){runif(1, 0, 10)}else if(x==-1){runif(1, -1, 0)} else{0}
  })
  diag(newmat) <- runif(3, -1, 0)
  return(newmat)
}
```

Given the input matrix `maxRE` will compute the eigenvalues and return the largest real part. 

```{r}
maxRE <- function(rmat){
  lam.max <- max(Re(eigen(rmat)$values))
  return(lam.max)
}

```

The above two functions are combined in `eig.analysis`. Given the number of desired sampling iterations, `n`, and a list of sign matrices to analyze, `matrices`, the `eig.analysis` function will return an  `n` by `length(matrices)` matrix of eigenvalues. Specifically it is returning the $max(Re(\lambda))$ for each sampled matrix. From this matrix quasi sign-stability can be calculated as the proportion of values in each column that are negative.  

```{r}
eig.analysis <- function(n, matrices){
  cols <- length(matrices)
  rows <- n
  eigenMATRIX <- matrix(0, nrow = rows, ncol = cols)
  for(i in 1:n){
    ranmat <- lapply(matrices, ran.unif)
    eigs <- sapply(ranmat, maxRE)
    eigenMATRIX[i,] <- eigs
  }
  return(eigenMATRIX)
}

```

# Analysis  

Load required packages
```{r}
library(igraph)
library(ggplot2)
library(reshape2)
```


## Determining motif frequency

Load in web data from GitHub. [Click here to download the .Rdata file](https://github.com/jjborrelli/Subgraph-Stability/blob/master/webGRAPHS.Rdata?raw=true). This file is a list of igraph graph objects for each of the 50 webs used in the analysis. Once you have downloaded the file into your working directory:

```{r wd, echo = F}
setwd("C:/Users/jjborrelli/Desktop/Github/Subgraph-Stability/")
#profile <- read.csv("normalizedPROFILE.csv", row.names = 1)

mus <- read.csv("permutedmeans.csv", row.names = 1)
sig <- read.csv("permutesd.csv", row.names = 1)
```

```{r getDATA}
load(paste(getwd(), "webGRAPHS.Rdata", sep = "/"))
```

The frequencies of each of the different subgraphs can now be determined easily with `motif_counter`. 

```{r}
motfreq <- motif_counter(web.graphs)
kable(motfreq, format = "pandoc")
```

The following code runs the null model analysis for the 50 food webs. First, each of the fifty webs are converted into binary adjacency matrices (`web.matrices`). Because the null model is a stochastic process the `set.seed(10)` allows for reproducible results. The code then loops through the list of adjacency matrices, generating 1000 permuted versions. The subgraphs are counted in each permuted matrix, and stored in a list (`p.mot`).   

```{r eval = F}
web.matrices <- lapply(web.graphs, get.adjacency, sparse = F)

set.seed(10)
pmot <- list()

for(i in 1:length(web.matrices)){
  p <- permutes_rc(web.matrices[[i]], 1000)
  g <- lapply(p, graph.adjacency)
  pmot[[i]] <- motif_counter(g)
  print(i)
}
```

Once subgraph counts have been obtained, the mean and standard deviation for each subgraph are computed. Z-scores are then computed as described in the methods section:  
$$
z_i = \frac{x_i - \overline{x}}{\sigma}
$$
In cases where there were no occurences of a subgraph (standard deviation = 0) `NaN` is produced following the appllication of the above formula. In these cases I have replaced the `NaN` with 0. The normalized profile was then computed (as desribed in the methods):  
$$
n_i = \frac{z_i}{\sqrt{\sum{z_j^2}}}
$$

```{r eval = F}
mus <- t(sapply(pmot, function(x){colMeans(x)}))
sig <- t(sapply(pmot, function(x){apply(x, 2, sd)}))
```

```{r}
z <- (motfreq - mus)/sig
zmat <- as.matrix(z)
zmat[is.nan(zmat)] <- 0
profile <- apply(zmat, 2, function(x){x/sqrt(rowSums(zmat^2))})
```


**Figure 1a** is then just a boxplot of the above object `profile`, reordered according to decreasing quasi sign-stability (see below).   

## Determining Quasi Sign-Stability  

The first step to get quasi sign stability is to get the largest eigenvalues from a series of randomly parameterized sign matrices. In the following code I generate 10000 random parameterizations for each of the 13 subgraphs's sign matrices (`mot.lst`). The `eig.analysis` function will return a matrix where each column is a different subgraph and each row is the largest eigenvalue of a particular randomization. 

```{r eigs, cache = T}
set.seed(5)

n <- 10000
mot.stab<- eig.analysis(n, mot.lst)
colnames(mot.stab) <- names(mot.lst)

```

From that matrix, quasi sign-stability is calculated as the proportion of rows with a negative value. In other words, how many random parameterizations of the sign matrix were locally stable? 

```{r qss}
mot.qss <- apply(mot.stab, 2, function(x){sum(x<0)/n})
sorted <- sort(mot.qss, decreasing = T)
sorted
```

### Correlation  
Compute the correlation between QSS and median z-score  
```{r cor}
med.z <- apply(zmat[,names(sorted)], 2, median)

cor.test(sorted, med.z)
```



# Code for the figures

```{r}
plot.df <- melt(profile[,names(sorted)])

fplot <- ggplot(plot.df, aes(x = Var2, y = value)) + geom_boxplot()
fplot <- fplot + geom_hline(aes(yintercept = 0), lty = 2, col = "red")
fplot <- fplot + theme_bw()
fplot + xlab("Subgraph") + ylab("Normalized Z-score")
```

```{r}
sort.df <- melt(sorted)

qssplot <- ggplot(sort.df, aes(x = 1:13, y = value)) + geom_point(shape = 19, size = 3) + theme_bw()
qssplot + xlab("Subgraph") + ylab("Quasi Sign-Stability") + scale_x_discrete(limits=names(sorted))
```

