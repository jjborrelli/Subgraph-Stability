s1<-matrix(c(0,1,0,-1,0,1,0,-1,0),nrow=3,ncol=3)
s2<-matrix(c(0,1,1,-1,0,1,-1,-1,0),nrow=3,ncol=3)
s3<-matrix(c(0,1,-1,-1,0,1,1,-1,0),nrow=3,ncol=3)
s4<-matrix(c(0,1,1,-1,0,0,-1,0,0),nrow=3,ncol=3)
s5<-matrix(c(0,0,1,0,0,1,-1,-1,0),nrow=3,ncol=3)
d1<-matrix(c(0,1,1,-1,0,1,-1,1,0),nrow=3,ncol=3)
d2<-matrix(c(0,1,1,1,0,1,-1,-1,0),nrow=3,ncol=3)
d3<-matrix(c(0,1,-1,1,0,0,1,0,0),nrow=3,ncol=3)
d4<-matrix(c(0,1,1,-1,0,0,1,0,0),nrow=3,ncol=3)
d5<-matrix(c(0,1,1,-1,0,1,1,-1,0),nrow=3,ncol=3)
d6<-matrix(c(0,1,1,1,0,1,1,1,0),nrow=3,ncol=3)
d7<-matrix(c(0,1,1,1,0,1,1,-1,0),nrow=3,ncol=3)
d8<-matrix(c(0,1,1,1,0,0,1,0,0),nrow=3,ncol=3)
mot.lst <- list(s1, s2, s3, s4, s5, d1, d2, d3, d4, d5, d6, d7, d8)
names(mot.lst) <- c("s1", "s2", "s3", "s4", "s5", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8")
motif_counter <- function(graph.lists){
require(igraph)
if(!is.list(graph.lists)){
stop("The input should be a list of graph objects")
}
triad.count <- lapply(graph.lists, triad.census)
triad.matrix <- matrix(unlist(triad.count), nrow = length(graph.lists), ncol = 16, byrow = T)
colnames(triad.matrix) <- c("empty", "single", "mutual", "s5", "s4", "s1", "d4",
"d3", "s2", "s3","d8", "d2", "d1", "d5", "d7", "d6")
triad.df <- as.data.frame(triad.matrix)
motif.data.frame <- data.frame(s1 = triad.df$s1, s2 = triad.df$s2, s3 = triad.df$s3, s4 = triad.df$s4,
s5 = triad.df$s5, d1 = triad.df$d1, d2 = triad.df$d2, d3 = triad.df$d3, d4 = triad.df$d4,
d5 = triad.df$d5, d6 = triad.df$d6, d7 = triad.df$d7, d8 = triad.df$d8)
rownames(motif.data.frame) <- names(graph.lists)
return(motif.data.frame)
}
permutes_rc <- function(mat, iter = 100){
pattern1 <- matrix(c(0,1,1,0), nrow = 2, ncol = 2)
pattern2 <- matrix(c(1,0,0,1), nrow = 2, ncol = 2)
count <- 0
mat.list <- list()
for(i in 1:iter){
mat.list[[i]] <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))
}
while(count < iter){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
count <- count + 1
mat[srow, scol] <- pattern2
mat.list[[count]] <- mat
next
} else if(sum(test == pattern2) == 4){
count <- count + 1
mat[srow, scol] <- pattern1
mat.list[[count]] <- mat
next
} else {next}
}
matrices <- lapply(mat.list, as.matrix)
return(permuted.matrices = matrices)
}
ran.unif <- function(motmat){
newmat <- apply(motmat, c(1,2), function(x){
if(x==1){runif(1, 0, 10)}else if(x==-1){runif(1, -1, 0)} else{0}
})
diag(newmat) <- runif(3, -1, 0)
return(newmat)
}
maxRE <- function(rmat){
lam.max <- max(Re(eigen(rmat)$values))
return(lam.max)
}
eig.analysis <- function(n, matrices){
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(0, nrow = rows, ncol = cols)
for(i in 1:n){
ranmat <- lapply(matrices, ran.unif)
eigs <- sapply(ranmat, maxRE)
eigenMATRIX[i,] <- eigs
}
return(eigenMATRIX)
}
library(igraph)
library(ggplot2)
library(reshape2)
load(paste(getwd(), "webGRAPHS.Rdata", sep = "/"))
getwd()
web.matrices <- lapply(web.graphs, get.adjacency, sparse = F)
permutes_rc <- function(mat, iter = 100, burn.in){
pattern1 <- matrix(c(0,1,1,0), nrow = 2, ncol = 2)
pattern2 <- matrix(c(1,0,0,1), nrow = 2, ncol = 2)
for(i in 1:burn.in){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
count <- count + 1
mat[srow, scol] <- pattern2
next
} else if(sum(test == pattern2) == 4){
count <- count + 1
mat[srow, scol] <- pattern0
next
} else {next}
}
count <- 0
mat.list <- list()
for(i in 1:iter){
mat.list[[i]] <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))
}
while(count < iter){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
count <- count + 1
mat[srow, scol] <- pattern2
mat.list[[count]] <- mat
next
} else if(sum(test == pattern2) == 4){
count <- count + 1
mat[srow, scol] <- pattern1
mat.list[[count]] <- mat
next
} else {next}
}
matrices <- lapply(mat.list, as.matrix)
return(permuted.matrices = matrices)
}
system.time(p <- permutes_rc(web.matrices[[1]], 1000, burn.in = 10000)
)
permutes_rc <- function(mat, iter = 100, burn.in){
pattern1 <- matrix(c(0,1,1,0), nrow = 2, ncol = 2)
pattern2 <- matrix(c(1,0,0,1), nrow = 2, ncol = 2)
for(i in 1:burn.in){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
mat[srow, scol] <- pattern2
next
} else if(sum(test == pattern2) == 4){
mat[srow, scol] <- pattern0
next
} else {next}
}
count <- 0
mat.list <- list()
for(i in 1:iter){
mat.list[[i]] <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))
}
while(count < iter){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
count <- count + 1
mat[srow, scol] <- pattern2
mat.list[[count]] <- mat
next
} else if(sum(test == pattern2) == 4){
count <- count + 1
mat[srow, scol] <- pattern1
mat.list[[count]] <- mat
next
} else {next}
}
matrices <- lapply(mat.list, as.matrix)
return(permuted.matrices = matrices)
}
system.time(p <- permutes_rc(web.matrices[[1]], 1000, burn.in = 10000)
)
permutes_rc <- function(mat, iter = 100, burn.in){
pattern1 <- matrix(c(0,1,1,0), nrow = 2, ncol = 2)
pattern2 <- matrix(c(1,0,0,1), nrow = 2, ncol = 2)
for(i in 1:burn.in){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
mat[srow, scol] <- pattern2
next
} else if(sum(test == pattern2) == 4){
mat[srow, scol] <- pattern1
next
} else {next}
}
count <- 0
mat.list <- list()
for(i in 1:iter){
mat.list[[i]] <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))
}
while(count < iter){
srow <- sample(1:nrow(mat), 2)
scol <- sample(1:ncol(mat), 2)
test <- mat[srow, scol]
if(sum(test == pattern1) == 4){
count <- count + 1
mat[srow, scol] <- pattern2
mat.list[[count]] <- mat
next
} else if(sum(test == pattern2) == 4){
count <- count + 1
mat[srow, scol] <- pattern1
mat.list[[count]] <- mat
next
} else {next}
}
matrices <- lapply(mat.list, as.matrix)
return(permuted.matrices = matrices)
}
system.time(p <- permutes_rc(web.matrices[[1]], 1000, burn.in = 10000))
p
str(p)
ran.unif <- function(motmat){
newmat <- apply(motmat, c(1,2), function(x){
if(x==1){runif(1, 0, 10)}else if(x==-1){runif(1, -1, 0)} else{0}
})
diag(newmat) <- runif(3, -1, 0)
return(newmat)
}
maxRE <- function(rmat){
lam.max <- max(Re(eigen(rmat)$values))
return(lam.max)
}
eig.analysis <- function(n, matrices){
cols <- length(matrices)
rows <- n
eigenMATRIX <- matrix(0, nrow = rows, ncol = cols)
for(i in 1:n){
ranmat <- lapply(matrices, ran.unif)
eigs <- sapply(ranmat, maxRE)
eigenMATRIX[i,] <- eigs
}
return(eigenMATRIX)
}
library(igraph)
library(ggplot2)
library(reshape2)
web.matrices <- lapply(web.graphs, get.adjacency, sparse = F)
set.seed(10)
pmot <- list()
for(i in 1:length(web.matrices)){
p <- permutes_rc(web.matrices[[i]], 1000, burn.in = 10000)
g <- lapply(p, graph.adjacency)
pmot[[i]] <- motif_counter(g)
print(i)
}
pmot
mus <- t(sapply(pmot, function(x){colMeans(x)}))
sig <- t(sapply(pmot, function(x){apply(x, 2, sd)}))
z <- (motfreq - mus)/sig
zmat <- as.matrix(z)
zmat[is.nan(zmat)] <- 0
profile <- apply(zmat, 2, function(x){x/sqrt(rowSums(zmat^2))})
motfreq <- motif_counter(web.graphs)
z <- (motfreq - mus)/sig
zmat <- as.matrix(z)
zmat[is.nan(zmat)] <- 0
profile <- apply(zmat, 2, function(x){x/sqrt(rowSums(zmat^2))})
boxplot(profile)
mot.qss <- apply(mot.stab, 2, function(x){sum(x<0)/n})
set.seed(5)
n <- 10000
mot.stab<- eig.analysis(n, mot.lst)
colnames(mot.stab) <- names(mot.lst)
mot.qss <- apply(mot.stab, 2, function(x){sum(x<0)/n})
sorted <- sort(mot.qss, decreasing = T)
sorted
boxplot(profile[sorted])
boxplot(profile[,sorted])
boxplot(profile[,names(sorted)])
